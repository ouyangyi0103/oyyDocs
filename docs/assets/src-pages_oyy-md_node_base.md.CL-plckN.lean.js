import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.CBoF8BIX.js";const t="/oyyDocs/node/npm.png",p="/oyyDocs/node/ps1.png",e="/oyyDocs/node/ps2.png",h="/oyyDocs/node/ps3.png",m=JSON.parse('{"title":"","description":"自我学习，努力上进","frontmatter":{"outline":"deep","head":[["meta",{"name":"title","content":"自我学习"}],["meta",{"name":"description","content":"自我学习，努力上进"}]]},"headers":[],"relativePath":"src-pages/oyy-md/node/base.md","filePath":"src-pages/oyy-md/node/base.md","lastUpdated":null}'),k={name:"src-pages/oyy-md/node/base.md"};function d(r,s,F,o,g,c){return l(),a("div",null,s[0]||(s[0]=[n(`<h2 id="一、node-概述" tabindex="-1">一、node 概述 <a class="header-anchor" href="#一、node-概述" aria-label="Permalink to &quot;一、node 概述&quot;">​</a></h2><ul><li><ol><li>node 并不是 js 应用，也不是一个编程语言，它是一个开源、跨平台的运行时环境</li></ol></li><li><ol start="2"><li>node 是构建在 V8 引擎之上的，V8 引擎是由 C/C++编写的，因此我们的 JavaSCript 代码需要由 C/C++转化后再执行。</li></ol></li><li><ol start="3"><li>node 使用<code>异步 I/O 和事件驱动</code>的设计理念，可以高效地处理大量并发请求，提供了非阻塞式 I/O 接口和事件循环机制，使得开发人员可以编写高性能、可扩展的应用程序,异步 I/O 最终都是由 libuv 事件循环库去实现的。</li></ol></li><li><ol start="4"><li>node 适合干一些<code>IO密集型应用</code>，不适合 <code>CPU密集型应用</code>，node 的 IO 依靠 libuv 有很强的处理能力，而 CPU 因为 nodejs 单线程原因，容易造成 CPU 占用率高，如果非要做 CPU 密集型应用，可以使用 C++插件编写 或者 nodejs 提供的 cluster。(CPU 密集型指的是图像的处理 或者音频处理需要大量数据结构 + 算法)</li></ol></li></ul><h2 id="二、npm-包管理器" tabindex="-1">二、npm 包管理器 <a class="header-anchor" href="#二、npm-包管理器" aria-label="Permalink to &quot;二、npm 包管理器&quot;">​</a></h2><p>npm（全称 Node Package Manager）是 Node.js 的包管理工具，它是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</p><h3 id="_1-npm-命令" tabindex="-1">1.npm 命令 <a class="header-anchor" href="#_1-npm-命令" aria-label="Permalink to &quot;1.npm 命令&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> init：初始化一个新的</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 项目，创建</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 文件。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">：安装指定的包。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s：安装指定的包，并将其添加到</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 文件中的依赖列表中。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D：安装指定的包，并将其添加到</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 文件中的开发依赖列表中。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">：全局安装指定的包。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 将本地模块链接到全局的</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 目录下</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 用于列出所有的</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置信息。执行该命令可以查看当前系统和用户级别的所有</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 用于获取当前</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置中的</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置项的值。registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置项用于指定</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 包的下载地址，如果未指定，则默认使用</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 官方的包注册表地址</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">registry-ur</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 命令，将</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置项的值修改为指定的</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">registry-ur</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 地址</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>package.json 中的 version 解释： 三段式版本号一般是这种 1.0.0，代表大版本号 次版本号 修订号， 大版本号一般是有重大变化才会升级， 次版本号一般是增加功能进行升级， 修订号一般是修改 bug 进行升级</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>npm install 安装模块的时候一般是扁平化安装的，但是有时候出现嵌套的情况是因为版本不同 A 依赖 C1.0, B 依赖 C1.0, D 依赖 C2.0, 此时 C 1.0 就会被放到 A B 的 node_moduels, C2.0 会被放入 D 模块下面的 node_moduels</p></div><h2 id="三、npm-install-原理" tabindex="-1">三、npm install 原理 <a class="header-anchor" href="#三、npm-install-原理" aria-label="Permalink to &quot;三、npm install 原理&quot;">​</a></h2><h3 id="执行-npm-install-的时候发生了什么" tabindex="-1">执行 npm install 的时候发生了什么? <a class="header-anchor" href="#执行-npm-install-的时候发生了什么" aria-label="Permalink to &quot;执行 npm install 的时候发生了什么?&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>首先安装的依赖都会存放在根目录的 node_modules,默认采用扁平化的方式安装，并且进行排序，规则是.bin 第一个然后@系列，再然后按照首字母排序 abcd 等，并且使用的算法是广度优先遍历，在遍历依赖树时，npm 会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。在处理每个依赖时，npm 会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本</p></div><h3 id="执行-npm-install-的后续流程" tabindex="-1">执行 npm install 的后续流程 <a class="header-anchor" href="#执行-npm-install-的后续流程" aria-label="Permalink to &quot;执行 npm install 的后续流程&quot;">​</a></h3><p><img src="`+t+'" alt="npm"></p><h3 id="package-lock-json-的作用" tabindex="-1">package-lock.json 的作用 <a class="header-anchor" href="#package-lock-json-的作用" aria-label="Permalink to &quot;package-lock.json 的作用&quot;">​</a></h3><p>它不仅仅可以锁定版本记录依赖树详细信息，还可以做缓存</p><ul><li>name 包名</li><li>version 该参数指定了当前包的版本号</li><li>resolved 该参数指定了当前包的下载地址</li><li>integrity 用于验证包的完整性</li><li>dev 该参数指定了当前包是一个开发依赖包</li><li>bin 该参数指定了当前包中可执行文件的路径和名称</li><li>engines 该参数指定了当前包所依赖的 Node.js 版本范围</li></ul><p>他会通过 <code>name + version + integrity</code> 信息生成一个唯一的 key，这个 key 能找到对应的 npm cache 文件夹下的 index-v5 下的缓存记录，如果发现有缓存记录，就会找到 tar 包的 hash 值，然后将对应的二进制文件解压到 node_modules</p><h2 id="四、npm-run-原理" tabindex="-1">四、npm run 原理 <a class="header-anchor" href="#四、npm-run-原理" aria-label="Permalink to &quot;四、npm run 原理&quot;">​</a></h2><p><img src="'+p+'" alt="npm"> 读取 package json 的 scripts 对应的脚本命令(dev:vite),vite 是个可执行脚本，他的查找规则是：</p><ul><li>先从当前项目的 node_modules/.bin 去查找可执行命令 vite</li><li>如果没找到就去全局的 node_modules 去找可执行命令 vite</li><li>如果还没找到就去环境变量查找</li><li>再找不到就进行报错</li></ul><p>如果成功找到会发现有三个文件，如下图 <img src="'+e+`" alt="npm"></p><ul><li>.sh 文件是给 Linux unix Macos 使用</li><li>.cmd 给 windows 的 cmd 使用</li><li>.ps1 给 windows 的 powerShell 使用</li></ul><h3 id="npm-生命周期" tabindex="-1">npm 生命周期 <a class="header-anchor" href="#npm-生命周期" aria-label="Permalink to &quot;npm 生命周期&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;predev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node prev.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;postdev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node post.js&quot;</span></span></code></pre></div><p>执行 npm run dev 命令的时候 predev 会自动执行，他的生命周期是在 dev 之前执行，然后执行 dev 命令，再然后执行 postdev，也就是 dev 之后执行</p><ul><li>运用场景： 例如 npm run build 可以在打包之后删除 dist 目录等等 post 例如你编写完一个工具发布 npm，那就可以在之后写一个 ci 脚本顺便帮你推送到 git 等等</li></ul><p><img src="`+h+'" alt="npm"></p>',27)]))}const E=i(k,[["render",d]]);export{m as __pageData,E as default};
